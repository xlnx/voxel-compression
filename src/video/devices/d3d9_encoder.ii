#include <vocomp/video/devices/d3d9_encoder.hpp>
#include <d3d9.h>
#include <dxva2api.h>
#include <wrl.h>
#include <nvcodec/nvEncoderD3D9.h>

namespace vol
{
VM_BEGIN_MODULE( video )

using namespace Microsoft::WRL;

struct D3D9Context
{
	D3D9Context( uint32_t width, uint32_t height )
	{
		auto iGpu = 0;

		Direct3DCreate9Ex( D3D_SDK_VERSION, pD3D.GetAddressOf() );

		D3DPRESENT_PARAMETERS d3dpp = { 0 };
		d3dpp.BackBufferWidth = width;
		d3dpp.BackBufferHeight = height;
		d3dpp.BackBufferFormat = D3DFMT_A8R8G8B8;
		d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
		d3dpp.EnableAutoDepthStencil = FALSE;
		d3dpp.PresentationInterval = D3DPRESENT_INTERVAL_IMMEDIATE;
		d3dpp.FullScreen_RefreshRateInHz = D3DPRESENT_RATE_DEFAULT;
		d3dpp.Windowed = TRUE;
		d3dpp.hDeviceWindow = NULL;

		pD3D->CreateDevice( iGpu, D3DDEVTYPE_HAL, NULL,
							D3DCREATE_HARDWARE_VERTEXPROCESSING,
							&d3dpp, pDevice.GetAddressOf() );

		D3DADAPTER_IDENTIFIER9 id;
		pD3D->GetAdapterIdentifier( iGpu, 0, &id );
		std::cout << "GPU in use: " << id.Description << std::endl;

		pDevice->CreateOffscreenPlainSurface( width, height,
											  D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT,
											  pSurfaceBgra.GetAddressOf(), NULL );
	}

public:
	ComPtr<IDirect3DDevice9> pDevice;
	ComPtr<IDirect3D9Ex> pD3D;
	ComPtr<IDirect3DSurface9> pSurfaceBgra;
};

struct D3D9EncoderImpl
{
	D3D9EncoderImpl( uint32_t width, uint32_t height, NV_ENC_BUFFER_FORMAT format ) :
	  ctx( width, height ),
	  _( ctx.pDevice.Get(), width, height, format ),
	  width( width ),
	  height( height )
	{
	}

	D3D9Context ctx;
	NvEncoderD3D9 _;
	uint32_t width, height;
};

D3D9Encoder::D3D9Encoder( uint32_t width, uint32_t height, PixelFormat format ) :
  _( [&] {
	  NV_ENC_BUFFER_FORMAT nv_format;
	  get_pixel_format( &nv_format, format );
	  return new D3D9EncoderImpl( width, height, nv_format );
  }() )
{
}

D3D9Encoder::~D3D9Encoder()
{
}

void D3D9Encoder::encode( Reader &reader, Writer &writer )
{
	auto &_ = this->_->_;

	int nSize = this->_->width * this->_->height * 4;
	std::unique_ptr<uint8_t[]> pHostFrame( new uint8_t[ nSize ] );
	int nFrame = 0;

	while ( true ) {
		std::vector<std::vector<uint8_t>> vPacket;
		auto nRead = reader.read( reinterpret_cast<char *>( pHostFrame.get() ), nSize );
		if ( nRead == nSize ) {
			const NvEncInputFrame *encoderInputFrame = _.GetNextInputFrame();
			IDirect3DSurface9 *pEncodeInputSurface = reinterpret_cast<IDirect3DSurface9 *>( encoderInputFrame->inputPtr );
			IDirect3DSurface9 *pRGBSurface = pEncodeInputSurface;
			// Load frame into pSurfaceBgra
			D3DLOCKED_RECT lockedRect;
			pRGBSurface->LockRect( &lockedRect, NULL, 0 );
			for ( int y = 0; y < this->_->height; y++ ) {
				memcpy( (uint8_t *)lockedRect.pBits + y * lockedRect.Pitch,
						pHostFrame.get() + y * this->_->width * 4, this->_->width * 4 );
			}
			pRGBSurface->UnlockRect();
			_.EncodeFrame( vPacket );
		} else {
			_.EndEncode( vPacket );
		}

		nFrame += (int)vPacket.size();

		for ( auto &packet : vPacket ) {
			writer.write( reinterpret_cast<char *>( packet.data() ), packet.size() );
		}

		if ( nRead != nSize ) break;
	}
}

void *D3D9Encoder::get_nv_impl()
{
	return &_->_;
}

VM_END_MODULE()

}  // namespace vol
